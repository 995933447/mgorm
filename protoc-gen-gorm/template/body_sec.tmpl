{{ if .ShouldGenModel }}
const (
	{{ .MessageName }}DbName   = "{{ .DbName }}"
	{{ .MessageName }}TbName   = "{{ .TbName }}"
	{{ .MessageName }}ConnName = "{{ .ConnName }}"
	{{ if not .DisabledAutoExpireAt }}
	{{ .MessageName }}TtlSec = {{ .ExpireTtlDays }} * 24 * 3600
	{{ end }}
)

// 索引
var {{ .FirstCharLowerMessageName }}IndexKeys = []string{
	{{- range .IndexKeys }}
	"{{ . }}",
	{{- end }}
}

var {{ .FirstCharLowerMessageName }}UniqueIndexKeys = []string{
	{{- range .UniqIndexKeys }}
	"{{ . }}",
	{{- end }}
}

var {{ .FirstCharLowerMessageName }}ExpireIndexKeys = []string{
	{{- range .ExpireIndexKeys }}
	"{{ . }}",
	{{- end }}
}
{{ end }}

type {{ .MessageName }}{{ .OrmStructNameSuffix }} struct {
	{{- if .ShouldGenModel }}
	{{ .PrimaryIdFieldName }} primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	{{- end }}

	{{- range .Fields }}
	{{ .Name }} {{ .TypeName }} {{if .Tags}}`{{ .Tags }}`{{else}}`json:"{{ .JsonTag }}" bson:"{{ .BsonTag }}"`{{end}}
	{{- end }}

	{{- if .ShouldGenModel }}
	{{- if not .DisabledAutoCreatedAt }}
	CreatedAt time.Time `json:"created_at,omitempty" bson:"created_at,omitempty"`
	{{- end }}
	{{- if not .DisabledAutoUpdatedAt }}
	UpdatedAt time.Time `json:"updated_at,omitempty" bson:"updated_at,omitempty"`
	{{- end }}
	{{- if not .DisabledAutoExpireAt }}
	ExpireAt time.Time `json:"expire_at,omitempty" bson:"expire_at,omitempty"`
	{{- end }}
	{{- end }}
}

{{range .NestedMessages}}
type {{ .MessageName }} struct {
	{{- range .Fields }}
	{{ .Name }} {{ .TypeName }} `json:"{{ .JsonTag }}" bson:"{{ .BsonTag }}"`
	{{- end }}
}
{{end}}

{{ if .ShouldGenModel }}
var {{ .FirstCharLowerMessageName }}{{ .OrmStructNameSuffix }}Cache mgorm.Cache

func Set{{ .MessageName }}{{ .OrmStructNameSuffix }}Cache(cache mgorm.Cache) {
	{{ .FirstCharLowerMessageName }}{{ .OrmStructNameSuffix }}Cache = cache
}

var on{{ .MessageName }}OrmQueryDone mgorm.OnQueryDoneFunc

func Set{{ .MessageName }}OrmOnQueryDone(fn mgorm.OnQueryDoneFunc) {
	on{{ .MessageName }}OrmQueryDone = fn
}

func New{{ .MessageName }}{{ .OrmModelNameSuffix }}({{ SprintNewModelArgs .ConnIdxTypes .DbIdxTypes .TbIdxTypes }}) *{{ .MessageName }}{{ .OrmModelNameSuffix }} {
	cache := {{ .FirstCharLowerMessageName }}{{ .OrmStructNameSuffix }}Cache
    if cache == nil {
    	cache = mgorm.DefaultCache
    }
	orm := mgorm.NewOrm(
    	{{- if .HasConnIdxes }}
        fmt.Sprintf({{ .MessageName }}ConnName, {{ SprintConnIdxes .ConnIdxTypes }}),
        {{- else }}
        {{ .MessageName }}ConnName,
        {{- end }}
        {{- if .HasDbIdxes }}
        fmt.Sprintf({{ .MessageName }}DbName, {{ SprintDbIdxes .DbIdxTypes }}),
        {{- else }}
        {{ .MessageName }}DbName,
        {{- end }}
        {{- if .HasTbIdxes }}
        fmt.Sprintf({{ .MessageName }}TbName, {{ SprintTbIdxes .TbIdxTypes }}),
        {{- else }}
        {{ .MessageName }}TbName,
        {{- end }}
        {{ .Cached }},
        cache,
        {{ .FirstCharLowerMessageName }}IndexKeys,
        {{ .FirstCharLowerMessageName }}UniqueIndexKeys,
        {{ .FirstCharLowerMessageName }}ExpireIndexKeys,
    )
    onQueryDoneFunc := on{{ .MessageName }}OrmQueryDone
    if onQueryDoneFunc == nil {
    	onQueryDoneFunc = mgorm.OnQueryDone
    }
    orm.SetOnQueryDone(onQueryDoneFunc)
	return &{{ .MessageName }}{{ .OrmModelNameSuffix }}{
		Model: mgorm.Model[{{ .MessageName }}{{ .OrmStructNameSuffix }}]{
			Orm: orm,
			Cached: {{ .Cached }},
		},
	}
}

type {{ .MessageName }}{{ .OrmModelNameSuffix }} struct {
	mgorm.Model[{{ .MessageName }}{{ .OrmStructNameSuffix }}]
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) NormalizeOrmForInsert(data *{{ .MessageName }}{{ .OrmStructNameSuffix }}) {
	if data.{{ .PrimaryIdFieldName }}.IsZero() {
		data.{{ .PrimaryIdFieldName }} = primitive.NewObjectID()
	}
	{{- if not .DisabledAutoCreatedAt }}
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	{{- end }}
	{{- if not .DisabledAutoUpdatedAt }}
	data.UpdatedAt = data.CreatedAt
	{{- end }}
	{{- if not .DisabledAutoExpireAt }}
	if data.ExpireAt.IsZero() {
		r := rand.New(rand.NewSource(time.Now().UnixNano()))
		data.ExpireAt = time.Now().Add(({{ .MessageName }}TtlSec + time.Duration(r.Int63n(10800))) * time.Second)
	}
	{{- end }}
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) InsertOneIgnoreConflict(ctx context.Context, data *{{ .MessageName }}{{ .OrmStructNameSuffix }}) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOneIgnoreConflict(ctx, data)
	return err
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) InsertOne(ctx context.Context, data *{{ .MessageName }}{{ .OrmStructNameSuffix }}) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOne(ctx, data)
	return err
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) InsertMany(ctx context.Context, dataList []*{{ .MessageName }}{{ .OrmStructNameSuffix }}) error {
	var ins []any
	for _, data := range dataList {
		m.NormalizeOrmForInsert(data)
		ins = append(ins, data)
	}
	_, err := m.Model.InsertMany(ctx, ins)
	return err
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) GetCacheKeys(data *{{ .MessageName }}{{ .OrmStructNameSuffix }}) []string {
	var cacheKeys []string
	cacheKeys = append(cacheKeys, fmt.Sprintf("_id:%s", data.{{ .PrimaryIdFieldName }}.Hex()))
	{{- range .TopFieldUniqIdxInfos }}
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"{{ .CacheKeyWithPlaceholder }}",
		{{- range .Fields }}data.{{ .Name }},{{- end }}
	))
	{{- end }}
	return cacheKeys
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) Update(ctx context.Context, data *{{ .MessageName }}{{ .OrmStructNameSuffix }}) (*mongo.UpdateResult, error) {
	dataB, err := mgorm.ToBsonM(data)
	if err != nil {
		return nil, err
	}

	{{- if .Cached }}
	old, err := m.Model.FindOneBy{{ .PrimaryIdFieldName }}(ctx, data.{{ .PrimaryIdFieldName }}.Hex())
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	{{- end }}

	{{- if not .DisabledAutoUpdatedAt }}
	dataB["updated_at"] = time.Now()
	{{- end }}
	return m.Model.UpdateOne(ctx, bson.M{"_id": dataB["_id"]}, bson.M{"$set": dataB})
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) UpdateOne(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	{{- if .Cached }}
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	{{- end }}

	{{- if not .DisabledAutoUpdatedAt }}
	data["updated_at"] = time.Now()
	{{- end }}
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": data})
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) UpdateMany(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	{{- if .Cached }}
	list, err := m.Model.FindAll(ctx, filter)
	if err != nil {
		return nil, err
	}
	if len(list) > 0 {
		var cacheKeys []string
		for _, item := range list {
			cacheKeys = append(cacheKeys, m.GetCacheKeys(item)...)
		}
		defer m.Model.DelCache(cacheKeys)
	}
	{{- end }}

	{{- if not .DisabledAutoUpdatedAt }}
	data["updated_at"] = time.Now()
	{{- end }}
	return m.Model.UpdateMany(ctx, filter, bson.M{"$set": data})
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) Upsert(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	{{- if not .DisabledAutoUpdatedAt }}
	data["updated_at"] = time.Now()
	{{- end }}
	{{- if not .DisabledAutoCreatedAt }}
	insertData["created_at"] = time.Now()
	{{- end }}

	{{- if .Cached }}
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	{{- end }}

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$setOnInsert": insertData})
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) UpInc(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	{{- if not .DisabledAutoCreatedAt }}
	insertData["created_at"] = time.Now()
	{{- end }}

	{{- if .Cached }}
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	{{- end }}

	return m.Model.Upsert(ctx, filter, bson.M{"$inc": data, "$set": bson.M{"updated_at": time.Now()}, "$setOnInsert": insertData})
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) UpAndInc(ctx context.Context, filter any, data, incdata bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	{{- if not .DisabledAutoUpdatedAt }}
	data["updated_at"] = time.Now()
	{{- end }}
	{{- if not .DisabledAutoCreatedAt }}
	insertData["created_at"] = time.Now()
	{{- end }}

	{{- if .Cached }}
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	{{- end }}

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$inc": incdata, "$setOnInsert": insertData})
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) DeleteOne(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	{{- if .Cached }}
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	{{- end }}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) DeleteMany(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	{{- if .Cached }}
	list, err := m.Model.FindAll(ctx, filter)
	if err != nil {
		return nil, err
	}
	if len(list) > 0 {
		var cacheKeys []string
		for _, item := range list {
			cacheKeys = append(cacheKeys, m.GetCacheKeys(item)...)
		}
		defer m.Model.DelCache(cacheKeys)
	}
	{{- end }}
	return m.Model.DeleteMany(ctx, filter)
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) UpdateOneBy{{ .PrimaryIdFieldName }}(ctx context.Context, id string, data bson.M) (*mongo.UpdateResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	{{- if .Cached }}
	old, err := m.Model.FindOneBy{{ .PrimaryIdFieldName }}(ctx, id)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	{{- end }}

	{{- if not .DisabledAutoUpdatedAt }}
	data["updated_at"] = time.Now()
	{{- end }}
	return m.Model.UpdateOne(ctx, bson.M{"_id": objId}, bson.M{"$set": data})
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) DeleteOneBy{{ .PrimaryIdFieldName }}(ctx context.Context, id string) (*mongo.DeleteResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	{{- if .Cached }}
	old, err := m.Model.FindOneBy{{ .PrimaryIdFieldName }}(ctx, id)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	{{- end }}

	return m.Model.DeleteOne(ctx, bson.M{"_id": objId})
}

func (m *{{ .MessageName }}{{ .OrmModelNameSuffix }}) FindOneBy{{ .PrimaryIdFieldName }}(ctx context.Context, id string) (*{{ .MessageName }}{{ .OrmStructNameSuffix }}, error) {
	var data {{ .MessageName }}{{ .OrmStructNameSuffix }}
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": objId}
	cacheKey := fmt.Sprintf("_id:%s", id)
	err = m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

{{- $modName := .MessageName -}}
{{- $ormStructNameSuffix := .OrmStructNameSuffix}}
{{- $ormModelNameSuffix := .OrmModelNameSuffix}}

{{- range .TopFieldUniqIdxInfos }}
{{ if .NamedByJoinAnd }}
func (m *{{$modName}}{{$ormModelNameSuffix}}) UpdateOneBy{{.NamedByJoinAnd}}(ctx context.Context, {{ range .Fields }}{{ Camel .Name }} {{ .Type }}, {{ end }}update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data {{$modName}}{{$ormStructNameSuffix}}
	{{- range .Fields }}
	filter["{{ .BsonName }}"] = {{ Camel .Name }}
	{{- end }}
	cacheKey := fmt.Sprintf(
		"{{ .CacheKeyWithPlaceholder }}",
		{{ range .Fields }}{{ Camel .Name }},{{ end }}
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *{{$modName}}{{$ormModelNameSuffix}}) FindOneBy{{.NamedByJoinAnd}}(ctx context.Context, {{ $last := Sub (len .Fields) 1 -}}{{ range $i, $f := .Fields }}{{ Camel $f.Name }} {{ $f.Type }}{{ if lt $i $last }}, {{ end }}{{- end }}) (*{{$modName}}{{$ormStructNameSuffix}}, error) {
	var data {{$modName}}{{$ormStructNameSuffix}}
	filter := bson.M{}
	{{- range .Fields }}
	filter["{{ .BsonName }}"] = {{ Camel .Name }}
	{{- end }}
	cacheKey := fmt.Sprintf(
		"{{ .CacheKeyWithPlaceholder }}",
		{{ range .Fields }}{{ Camel .Name }},{{ end }}
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *{{$modName}}{{$ormModelNameSuffix}}) DeleteOneBy{{.NamedByJoinAnd}}(ctx context.Context, {{ $last := Sub (len .Fields) 1 -}}{{ range $i, $f := .Fields }}{{ Camel $f.Name }} {{ $f.Type }}{{ if lt $i $last }}, {{ end }}{{- end }}) (*mongo.DeleteResult, error) {
	var data {{$modName}}{{$ormStructNameSuffix}}
	filter := bson.M{}
	{{- range .Fields }}
	filter["{{ .BsonName }}"] = {{ Camel .Name }}
	{{- end }}
	cacheKey := fmt.Sprintf(
		"{{ .CacheKeyWithPlaceholder }}",
		{{ range .Fields }}{{ Camel .Name }},{{ end }}
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}
{{- end }}
{{- end }}

{{- range .TopFieldIdxInfos }}
{{ if .NamedByJoinAnd }}
func (m *{{$modName}}{{$ormModelNameSuffix}}) FindManyBy{{.NamedByJoinAnd}}(ctx context.Context, {{ range .Fields }}{{ Camel .Name }} {{ .Type }}, {{ end }}sort bson.D, limit int64, selectors ...any) ([]*{{$modName}}{{$ormStructNameSuffix}}, error) {
	filter := bson.M{}
	{{- range .Fields }}
	filter["{{ .BsonName }}"] = {{ Camel .Name }}
	{{- end }}
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *{{$modName}}{{$ormModelNameSuffix}}) FindManyPageBy{{.NamedByJoinAnd}}(ctx context.Context, {{ range .Fields }}{{ Camel .Name }} {{ .Type }}, {{ end }}sort bson.D, page, pageSize int64, selectors ...any) ([]*{{$modName}}{{$ormStructNameSuffix}}, error) {
	filter := bson.M{}
	{{- range .Fields }}
	filter["{{ .BsonName }}"] = {{ Camel .Name }}
	{{- end }}
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *{{$modName}}{{$ormModelNameSuffix}}) FindAllBy{{.NamedByJoinAnd}}(ctx context.Context, {{ range .Fields }}{{ Camel .Name }} {{ .Type }}, {{ end }}sort bson.D, selectors ...any) ([]*{{$modName}}{{$ormStructNameSuffix}}, error) {
	filter := bson.M{}
	{{- range .Fields }}
	filter["{{ .BsonName }}"] = {{ Camel .Name }}
	{{- end }}
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *{{$modName}}{{$ormModelNameSuffix}}) UpdateManyBy{{.NamedByJoinAnd}}(ctx context.Context, {{ range .Fields }}{{ Camel .Name }} {{ .Type }}, {{ end }}data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	{{- range .Fields }}
	filter["{{ .BsonName }}"] = {{ Camel .Name }}
	{{- end }}
	return m.UpdateMany(ctx, filter, data)
}

func (m *{{$modName}}{{$ormModelNameSuffix}}) DeleteManyBy{{.NamedByJoinAnd}}(ctx context.Context, {{ $last := Sub (len .Fields) 1 -}}{{ range $i, $f := .Fields }}{{ Camel $f.Name }} {{ $f.Type }}{{ if lt $i $last }}, {{ end }}{{- end }}) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	{{- range .Fields }}
	filter["{{ .BsonName }}"] = {{ Camel .Name }}
	{{- end }}
	return m.DeleteMany(ctx, filter)
}
{{- end }}
{{- end }}
{{- end }}
