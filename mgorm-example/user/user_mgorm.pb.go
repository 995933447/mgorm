// Code generated by protoc-gen-mgorm. DO NOT EDIT.
package user

import (
	"context"
	"errors"

	"fmt"
	"time"
	"math/rand"

	"github.com/995933447/mgorm"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"github.com/995933447/mgorm/mgorm-example/common"
)

type AddressOrm struct {
	Street  string `json:"road" bson:"streets"`
	City    string `json:"ct,omitempty" bson:"cities,omitempty"`
	Country string `json:"country,omitempty" bson:"country,omitempty"`
}

const (
	UserDbName   = "test_example_%s"
	UserTbName   = "user_%d_%d_%s"
	UserConnName = "default"

	UserTtlSec = 7 * 24 * 3600
)

// 索引
var userIndexKeys = []string{
	"sex:gender",
	"username,age",
	"register_at",
	"uuid",
}

var userUniqueIndexKeys = []string{
	"id",
	"email,username",
	"username,address.city:user_city",
}

var userExpireIndexKeys = []string{
	"expire_at",
}

type UserOrm struct {
	ID               primitive.ObjectID          `json:"_id,omitempty" bson:"_id,omitempty"`
	Id               uint64                      `schema:"title=唯一标识"`
	Username         string                      `json:"username,omitempty" bson:"username,omitempty"`
	Email            string                      `json:"email,omitempty" bson:"email,omitempty"`
	Age              int32                       `json:"age,omitempty" bson:"age,omitempty"`
	Balance          float32                     `json:"balance,omitempty" bson:"balance,omitempty"`
	Active           bool                        `json:"active,omitempty" bson:"active,omitempty"`
	Score            float64                     `json:"score,omitempty" bson:"score,omitempty"`
	Avatar           []byte                      `json:"avatar,omitempty" bson:"avatar,omitempty"`
	Tags             map[string]string           `json:"tags,omitempty" bson:"tags,omitempty"`
	Interests        []string                    `json:"interests,omitempty" bson:"interests,omitempty"`
	Address          *AddressOrm                 `json:"address,omitempty" bson:"address,omitempty"`
	HistoryAddresses []*AddressOrm               `json:"history_addresses,omitempty" bson:"history_addresses,omitempty"`
	Sex              uint32                      `json:"sex,omitempty" bson:"sex,omitempty"`
	Desc             *common.Desc                `json:"desc,omitempty" bson:"desc,omitempty"`
	Desc2            *common.Desc2Orm            `json:"desc2,omitempty" bson:"desc2,omitempty"`
	Desc3            *common.Desc3Orm            `json:"desc3,omitempty" bson:"desc3,omitempty"`
	RegisterAt       time.Time                   `json:"register_at,omitempty" bson:"register_at,omitempty"`
	LoginAt          time.Time                   `json:"login_at,omitempty" bson:"login_at,omitempty"`
	Uuid             primitive.ObjectID          `json:"uuid,omitempty" bson:"uuid,omitempty"`
	Desc4            *User_Desc4Orm              `json:"desc4,omitempty" bson:"desc4,omitempty"`
	Desc4M           map[string]*User_Desc4Orm   `json:"desc4_m,omitempty" bson:"desc4_m,omitempty"`
	Desc4S           []*User_Desc4Orm            `json:"desc4_s,omitempty" bson:"desc4_s,omitempty"`
	Descs            []*common.Desc              `json:"descs,omitempty" bson:"descs,omitempty"`
	Mm               map[string]string           `json:"mm,omitempty" bson:"mm,omitempty"`
	Descm            map[string]*common.Desc     `json:"descm,omitempty" bson:"descm,omitempty"`
	Desc2S           []*common.Desc2Orm          `json:"desc2_s,omitempty" bson:"desc2_s,omitempty"`
	Desc3S           []*common.Desc3Orm          `json:"desc3_s,omitempty" bson:"desc3_s,omitempty"`
	Desc2M           map[string]*common.Desc2Orm `json:"desc2_m,omitempty" bson:"desc2_m,omitempty"`
	Desc3M           map[string]*common.Desc3Orm `json:"desc3_m,omitempty" bson:"desc3_m,omitempty"`
	Desc5M           map[string]*User_Desc5Orm   `json:"desc5_m,omitempty" bson:"desc5_m,omitempty"`
	Desc6S           []*User_Desc6Orm            `json:"desc6_s,omitempty" bson:"desc6_s,omitempty"`
	Desc6M           map[string]*User_Desc6Orm   `json:"desc6_m,omitempty" bson:"desc6_m,omitempty"`
	Desc7M           map[string]*User_Desc7Orm   `json:"desc7_m,omitempty" bson:"desc7_m,omitempty"`
	Desc8M           map[string]*User_Desc8Orm   `json:"desc8_m,omitempty" bson:"desc8_m,omitempty"`
	CreatedAt        time.Time                   `json:"created_at,omitempty" bson:"created_at,omitempty"`
	UpdatedAt        time.Time                   `json:"updated_at,omitempty" bson:"updated_at,omitempty"`
	ExpireAt         time.Time                   `json:"expire_at,omitempty" bson:"expire_at,omitempty"`
}

type User_Desc4Orm struct {
	Lang5 string `json:"lang5,omitempty" bson:"language"`
}

type User_Desc5Orm struct {
	Desc string `json:"desc,omitempty" bson:"desc,omitempty"`
}

type User_Desc6Orm struct {
}

type User_Desc7Orm struct {
}

type User_Desc8Orm struct {
}

var userOrmCache mgorm.Cache

func SetUserOrmCache(cache mgorm.Cache) {
	userOrmCache = cache
}

var onUserOrmQueryDone mgorm.OnQueryDoneFunc

func SetUserOrmOnQueryDone(fn mgorm.OnQueryDoneFunc) {
	onUserOrmQueryDone = fn
}

func NewUserModel(dbIdx string, tbIdx int64, tbIdx2 int64, tbIdx3 string) *UserModel {
	cache := userOrmCache
	if cache == nil {
		cache = mgorm.DefaultCache
	}
	orm := mgorm.NewOrm(
		UserConnName,
		fmt.Sprintf(UserDbName, dbIdx),
		fmt.Sprintf(UserTbName, tbIdx, tbIdx2, tbIdx3),
		true,
		cache,
		userIndexKeys,
		userUniqueIndexKeys,
		userExpireIndexKeys,
	)
	onQueryDoneFunc := onUserOrmQueryDone
	if onQueryDoneFunc == nil {
		onQueryDoneFunc = mgorm.OnQueryDone
	}
	orm.SetOnQueryDone(onQueryDoneFunc)
	return &UserModel{
		Model: mgorm.Model[UserOrm]{
			Orm:    orm,
			Cached: true,
		},
	}
}

type UserModel struct {
	mgorm.Model[UserOrm]
}

func (m *UserModel) NormalizeOrmForInsert(data *UserOrm) {
	if data.ID.IsZero() {
		data.ID = primitive.NewObjectID()
	}
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	data.UpdatedAt = data.CreatedAt
	if data.ExpireAt.IsZero() {
		r := rand.New(rand.NewSource(time.Now().UnixNano()))
		data.ExpireAt = time.Now().Add((UserTtlSec + time.Duration(r.Int63n(10800))) * time.Second)
	}
}

func (m *UserModel) InsertOneIgnoreConflict(ctx context.Context, data *UserOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOneIgnoreConflict(ctx, data)
	return err
}

func (m *UserModel) InsertOne(ctx context.Context, data *UserOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOne(ctx, data)
	return err
}

func (m *UserModel) InsertMany(ctx context.Context, dataList []*UserOrm) error {
	var ins []any
	for _, data := range dataList {
		m.NormalizeOrmForInsert(data)
		ins = append(ins, data)
	}
	_, err := m.Model.InsertMany(ctx, ins)
	return err
}

func (m *UserModel) GetCacheKeys(data *UserOrm) []string {
	var cacheKeys []string
	cacheKeys = append(cacheKeys, fmt.Sprintf("_id:%s", data.ID.Hex()))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"id:%d", data.Id,
	))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"email:%s_username:%s", data.Email, data.Username,
	))
	return cacheKeys
}

func (m *UserModel) Update(ctx context.Context, data *UserOrm) (*mongo.UpdateResult, error) {
	dataB, err := mgorm.ToBsonM(data)
	if err != nil {
		return nil, err
	}
	old, err := m.Model.FindOneByID(ctx, data.ID.Hex())
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	dataB["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": dataB["_id"]}, bson.M{"$set": dataB})
}

func (m *UserModel) UpdateOne(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": data})
}

func (m *UserModel) UpdateMany(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	list, err := m.Model.FindAll(ctx, filter)
	if err != nil {
		return nil, err
	}
	if len(list) > 0 {
		var cacheKeys []string
		for _, item := range list {
			cacheKeys = append(cacheKeys, m.GetCacheKeys(item)...)
		}
		defer m.Model.DelCache(cacheKeys)
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateMany(ctx, filter, bson.M{"$set": data})
}

func (m *UserModel) Upsert(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$setOnInsert": insertData})
}

func (m *UserModel) UpInc(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	insertData["created_at"] = time.Now()
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}

	return m.Model.Upsert(ctx, filter, bson.M{"$inc": data, "$set": bson.M{"updated_at": time.Now()}, "$setOnInsert": insertData})
}

func (m *UserModel) UpAndInc(ctx context.Context, filter any, data, incdata bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$inc": incdata, "$setOnInsert": insertData})
}

func (m *UserModel) DeleteOne(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *UserModel) DeleteMany(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	list, err := m.Model.FindAll(ctx, filter)
	if err != nil {
		return nil, err
	}
	if len(list) > 0 {
		var cacheKeys []string
		for _, item := range list {
			cacheKeys = append(cacheKeys, m.GetCacheKeys(item)...)
		}
		defer m.Model.DelCache(cacheKeys)
	}
	return m.Model.DeleteMany(ctx, filter)
}

func (m *UserModel) UpdateOneByID(ctx context.Context, id string, data bson.M) (*mongo.UpdateResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	old, err := m.Model.FindOneByID(ctx, id)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": objId}, bson.M{"$set": data})
}

func (m *UserModel) DeleteOneByID(ctx context.Context, id string) (*mongo.DeleteResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	old, err := m.Model.FindOneByID(ctx, id)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}

	return m.Model.DeleteOne(ctx, bson.M{"_id": objId})
}

func (m *UserModel) FindOneByID(ctx context.Context, id string) (*UserOrm, error) {
	var data UserOrm
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": objId}
	cacheKey := fmt.Sprintf("_id:%s", id)
	err = m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *UserModel) UpdateOneById(ctx context.Context, id uint64, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data UserOrm
	filter["id"] = id
	cacheKey := fmt.Sprintf(
		"id:%d",
		id,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *UserModel) FindOneById(ctx context.Context, id uint64) (*UserOrm, error) {
	var data UserOrm
	filter := bson.M{}
	filter["id"] = id
	cacheKey := fmt.Sprintf(
		"id:%d",
		id,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *UserModel) DeleteOneById(ctx context.Context, id uint64) (*mongo.DeleteResult, error) {
	var data UserOrm
	filter := bson.M{}
	filter["id"] = id
	cacheKey := fmt.Sprintf(
		"id:%d",
		id,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *UserModel) UpdateOneByEmailAndUsername(ctx context.Context, email string, username string, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data UserOrm
	filter["email"] = email
	filter["username"] = username
	cacheKey := fmt.Sprintf(
		"email:%s_username:%s",
		email, username,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *UserModel) FindOneByEmailAndUsername(ctx context.Context, email string, username string) (*UserOrm, error) {
	var data UserOrm
	filter := bson.M{}
	filter["email"] = email
	filter["username"] = username
	cacheKey := fmt.Sprintf(
		"email:%s_username:%s",
		email, username,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *UserModel) DeleteOneByEmailAndUsername(ctx context.Context, email string, username string) (*mongo.DeleteResult, error) {
	var data UserOrm
	filter := bson.M{}
	filter["email"] = email
	filter["username"] = username
	cacheKey := fmt.Sprintf(
		"email:%s_username:%s",
		email, username,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *UserModel) FindManyBySex(ctx context.Context, sex uint32, sort bson.D, limit int64, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["sex"] = sex
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *UserModel) FindManyPageBySex(ctx context.Context, sex uint32, sort bson.D, page, pageSize int64, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["sex"] = sex
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *UserModel) FindAllBySex(ctx context.Context, sex uint32, sort bson.D, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["sex"] = sex
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *UserModel) UpdateManyBySex(ctx context.Context, sex uint32, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["sex"] = sex
	return m.UpdateMany(ctx, filter, data)
}

func (m *UserModel) DeleteManyBySex(ctx context.Context, sex uint32) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["sex"] = sex
	return m.DeleteMany(ctx, filter)
}

func (m *UserModel) FindManyByUsernameAndAge(ctx context.Context, username string, age int32, sort bson.D, limit int64, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["username"] = username
	filter["age"] = age
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *UserModel) FindManyPageByUsernameAndAge(ctx context.Context, username string, age int32, sort bson.D, page, pageSize int64, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["username"] = username
	filter["age"] = age
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *UserModel) FindAllByUsernameAndAge(ctx context.Context, username string, age int32, sort bson.D, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["username"] = username
	filter["age"] = age
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *UserModel) UpdateManyByUsernameAndAge(ctx context.Context, username string, age int32, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["username"] = username
	filter["age"] = age
	return m.UpdateMany(ctx, filter, data)
}

func (m *UserModel) DeleteManyByUsernameAndAge(ctx context.Context, username string, age int32) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["username"] = username
	filter["age"] = age
	return m.DeleteMany(ctx, filter)
}

func (m *UserModel) FindManyByRegisterAt(ctx context.Context, registerAt time.Time, sort bson.D, limit int64, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["register_at"] = registerAt
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *UserModel) FindManyPageByRegisterAt(ctx context.Context, registerAt time.Time, sort bson.D, page, pageSize int64, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["register_at"] = registerAt
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *UserModel) FindAllByRegisterAt(ctx context.Context, registerAt time.Time, sort bson.D, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["register_at"] = registerAt
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *UserModel) UpdateManyByRegisterAt(ctx context.Context, registerAt time.Time, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["register_at"] = registerAt
	return m.UpdateMany(ctx, filter, data)
}

func (m *UserModel) DeleteManyByRegisterAt(ctx context.Context, registerAt time.Time) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["register_at"] = registerAt
	return m.DeleteMany(ctx, filter)
}

func (m *UserModel) FindManyByUuid(ctx context.Context, uuid primitive.ObjectID, sort bson.D, limit int64, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["uuid"] = uuid
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *UserModel) FindManyPageByUuid(ctx context.Context, uuid primitive.ObjectID, sort bson.D, page, pageSize int64, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["uuid"] = uuid
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *UserModel) FindAllByUuid(ctx context.Context, uuid primitive.ObjectID, sort bson.D, selectors ...any) ([]*UserOrm, error) {
	filter := bson.M{}
	filter["uuid"] = uuid
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *UserModel) UpdateManyByUuid(ctx context.Context, uuid primitive.ObjectID, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["uuid"] = uuid
	return m.UpdateMany(ctx, filter, data)
}

func (m *UserModel) DeleteManyByUuid(ctx context.Context, uuid primitive.ObjectID) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["uuid"] = uuid
	return m.DeleteMany(ctx, filter)
}
